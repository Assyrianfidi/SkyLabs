import express, { type Request, Response, NextFunction, ErrorRequestHandler } from "express";
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import { registerRoutes } from "./routes.js";
import { setupVite, serveStatic, log } from "./vite.js";
import { initializeDatabase } from "./db/index.js";
import { logError, logger } from "./utils/logger.js";
import { databaseMonitor } from "./services/databaseMonitor.js";
import { securityHeaders } from "./middleware/securityMiddleware.js";
import cspReportRouter from './routes/cspReport.js';
import { ZodError } from 'zod';
import { env } from './config/env.js';

// Validate required environment variables
function validateEnv() {
  const requiredVars = [
    'NODE_ENV',
    'DATABASE_URL',
    'SMTP_HOST',
    'SMTP_PORT',
    'SMTP_USER',
    'SMTP_PASS',
    'SMTP_FROM',
    'SMTP_TO'
  ];

  const missingVars = requiredVars.filter(varName => !process.env[varName]);
  
  if (missingVars.length > 0) {
    logger.error(`Missing required environment variables: ${missingVars.join(', ')}`);
    process.exit(1);
  }
}

// Error handling middleware
const errorHandler: ErrorRequestHandler = (err: any, req: Request, res: Response, _next: NextFunction) => {
  const statusCode = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';
  const stack = process.env.NODE_ENV === 'development' ? err.stack : undefined;
  const errorId = Math.random().toString(36).substring(2, 9);

  // Log the error with request details
  logger.error({
    errorId,
    message: err.message,
    stack: err.stack,
    path: req.path,
    method: req.method,
    body: req.body,
    query: req.query,
    params: req.params,
    userAgent: req.headers['user-agent'],
    ip: req.ip
  }, 'Request Error');

  // Handle different types of errors
  if (err instanceof ZodError) {
    return res.status(400).json({
      success: false,
      error: 'Validation Error',
      message: 'Invalid request data',
      details: err.errors,
      errorId
    });
  }

  // Default error response
  res.status(statusCode).json({
    success: false,
    error: statusCode === 500 ? 'Internal Server Error' : err.name,
    message,
    ...(process.env.NODE_ENV === 'development' && { stack }),
    errorId
  });
};

// Request logging middleware
function requestLogger(req: Request, res: Response, next: NextFunction) {
  const start = Date.now();
  const { method, originalUrl, ip } = req;
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    const { statusCode } = res;
    const logMessage = `${method} ${originalUrl} ${statusCode} - ${duration}ms - ${ip}`;
    
    if (statusCode >= 400) {
      logger.error({
        method,
        url: originalUrl,
        status: statusCode,
        duration,
        ip,
        userAgent: req.headers['user-agent']
      }, 'Request Error');
    } else {
      logger.info(logMessage);
    }
  });
  
  next();
}

// Initialize database monitoring
async function initializeApp() {
  try {
    logger.info('Initializing application...');
    
    // Validate environment variables
    validateEnv();
    
    // Initialize database connection and monitoring
    await initializeDatabase();
    await databaseMonitor.startMonitoring();
    
    // Verify database is responsive
    const stats = await databaseMonitor.getDatabaseStats();
    logger.info(`Database monitoring initialized. Size: ${stats.databaseSize}, Active connections: ${stats.activeConnections}`);
    
    return true;
  } catch (error) {
    await logError(
      error as Error,
      'Application Initialization',
      'System',
      'üî¥ Critical',
      { action: 'Failed to initialize application services' },
      'monitor_connection'
    );
    logger.error('‚ùå Failed to initialize application. Check ERROR_LOG.md for details.');
    process.exit(1);
  }
}

// Start the application
const app = express();

// Apply middleware
app.use(express.json({ limit: '10kb' }));
app.use(express.urlencoded({ extended: true, limit: '10kb' }));
app.use(requestLogger);

// CORS configuration
const allowedOrigins = [
  'http://localhost:3001',
  'http://127.0.0.1:3001',
  'http://localhost:5173',
  'http://127.0.0.1:5173',
  'http://localhost:3002',
  'http://127.0.0.1:3002',
  'https://skylabs.tech',
  'https://skylabs-1.onrender.com'
];

// Add any additional origins from environment variable
if (process.env.CORS_ORIGINS) {
  allowedOrigins.push(...process.env.CORS_ORIGINS.split(','));
}

const corsOptions = {
  origin: (origin: string | undefined, callback: (err: Error | null, allow?: boolean) => void) => {
    // Allow requests with no origin (like mobile apps or curl requests)
    if (!origin) return callback(null, true);
    
    // Allow all subdomains of onrender.com in production
    if (process.env.NODE_ENV === 'production' && origin.endsWith('.onrender.com')) {
      return callback(null, true);
    }
    
    // Allow explicitly listed origins
    if (allowedOrigins.includes(origin) || process.env.NODE_ENV === 'development') {
      return callback(null, true);
    }
    
    console.warn(`Blocked by CORS: ${origin}`);
    callback(new Error('Not allowed by CORS'));
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  allowedHeaders: [
    'Content-Type', 
    'Authorization', 
    'X-Requested-With', 
    'X-Content-Type-Options',
    'Origin',
    'Accept',
    'Accept-Version',
    'Content-Length',
    'Content-MD5',
    'Date',
    'X-Api-Version'
  ],
  exposedHeaders: [
    'Content-Length', 
    'X-Content-Length',
    'X-RateLimit-Limit',
    'X-RateLimit-Remaining',
    'X-RateLimit-Reset'
  ],
  maxAge: 86400, // 24 hours
  preflightContinue: false,
  optionsSuccessStatus: 204
};

// Apply CORS with the above options
app.use(cors(corsOptions));

// Handle preflight requests
// Configure CORS
app.use(cors({
  origin: (origin, callback) => {
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// Apply security middleware
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", 'data:'],
      connectSrc: ["'self'", 'https://api.example.com'],
      formAction: ["'self'"],
      frameAncestors: ["'none'"],
    },
  },
}));

app.use(securityHeaders);
app.use(helmet.hidePoweredBy());
app.use(helmet.noSniff());
app.use(helmet.xssFilter());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: { success: false, error: 'Too many requests, please try again later.' }
});

app.use('/api/', limiter);

// Register application routes
app.use('/api', (await registerRoutes(app)));

// 404 handler
app.use((req: Request, res: Response) => {
  res.status(404).json({
    success: false,
    error: 'Not Found',
    message: `Cannot ${req.method} ${req.path}`
  });
});

// Error handler
app.use((err: any, req: Request, res: Response, next: NextFunction) => {
  const status = err.status || 500;
  const message = err.message || 'Internal Server Error';
  const errorId = Math.random().toString(36).substring(2, 9);
  
  // Log the error
  logger.error({
    errorId,
    status,
    message,
    path: req.path,
    method: req.method,
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
  }, 'Request Error');
  
  // Send error response
  res.status(status).json({
    success: false,
    error: status === 500 ? 'Internal Server Error' : err.name,
    message,
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack }),
    errorId
  });
});

    // Don't expose internal errors in production
    const errorResponse = process.env.NODE_ENV === 'production' && status >= 500
      ? { 
          error: 'Internal Server Error',
          statusCode: 500
        }
      : { 
          error: message,
          statusCode: status,
          ...(process.env.NODE_ENV !== 'production' && { stack: err.stack }),
          ...('details' in err && { details: (err as any).details })
        };

    res.status(status).json(errorResponse);
  });

  // importantly only setup vite in development and after
  // setting up all the other routes so the catch-all route
  // doesn't interfere with the other routes
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }

  // Start the server
  const port = process.env.PORT ? parseInt(process.env.PORT) : 3002;
  
  server.listen(port, '0.0.0.0', () => {
    console.log(`üöÄ Server running at http://localhost:${port}`);
    
    // Start database monitoring after server is running
    databaseMonitor.startMonitoring().catch(err => {
      console.error('‚ùå Failed to start database monitoring:', err);
    });
  });

  // Handle server errors
  server.on('error', (error: NodeJS.ErrnoException) => {
    if (error.code === 'EADDRINUSE') {
      console.error(`‚ùå Port ${port} is already in use. Please check for other running instances.`);
    } else {
      console.error('‚ùå Server error:', error);
    }
    process.exit(1);
  });
})();
